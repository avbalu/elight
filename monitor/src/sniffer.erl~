%%%-------------------------------------------------------------------
%%% @author adoor balasubramanian <balu@localhost.localdomain>
%%% @copyright (C) 2014, adoor balasubramanian
%%% @doc
%%%
%%% @end
%%% Created : 28 Dec 2014 by adoor balasubramanian <balu@localhost.localdomain>
%%%-------------------------------------------------------------------
-module(monitor).

-behaviour(gen_server).

-include("../../common/common.hrl").

%% API
-export([start_link/2, end_session/2]).

%% gen_server callbacks
-export([init/1, handle_call/3, handle_cast/2, handle_info/2,
	 terminate/2, code_change/3]).

%%%===================================================================
%%% API
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% Starts the server
%%
%% @spec start_link(Device) -> {ok, Pid} | ignore | {error, Error}
%% @end
%%---------------------------------------------------------------------
-spec start_link(string(), string()) ->
    {ok, pid()}.

start_link(Type, Device) ->
    gen_server:start_link({local, list_to_atom(Device)}, ?MODULE, [Type, Device], []).

end_session(ServerRef, Key) ->
    gen_server:cast(ServerRef, Key).
%%%===================================================================
%%% gen_server callbacks
%%%===================================================================

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Initializes the server
%%
%% @spec init(Args) -> {ok, State} |
%%                     {ok, State, Timeout} |
%%                     ignore |
%%                     {stop, Reason}
%% @end
%%--------------------------------------------------------------------
-record(state, { port :: port(), 
		 db :: atom(),
		 filters :: [#filter{}]
	       }).

init([Type, Device]) ->
%    Command = filename:join(code:priv_dir(monitor) , "monitor"),
    Command = "/home/balu/elight/lib/monitor/priv/monitor",
    PortName = {spawn_executable, Command},
    PortSettings = [{packet, 2},
		    {args, [Type, Device]},
		    nouse_stdio,
		    exit_status,
		    in,
		    binary,
		    eof],
    Port = erlang:open_port(PortName, PortSettings),
    ets:new(list_to_atom(Device), [named_table]),
    [#config{key = filters,value = Filters}]
	= configdb:mread(running, filters),
    erlang:process_flag(trap_exit, true),
    {ok, #state{port = Port, 
		db = list_to_atom(Device),
		filters = Filters}}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Handling call messages
%%
%% @spec handle_call(Request, From, State) ->
%%                                   {reply, Reply, State} |
%%                                   {reply, Reply, State, Timeout} |
%%                                   {noreply, State} |
%%                                   {noreply, State, Timeout} |
%%                                   {stop, Reason, Reply, State} |
%%                                   {stop, Reason, State}
%% @end
%%--------------------------------------------------------------------
handle_call(_Request, _From, State) ->
    Reply = ok,
    {reply, Reply, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Handling cast messages
%%
%% @spec handle_cast(Msg, State) -> {noreply, State} |
%%                                  {noreply, State, Timeout} |
%%                                  {stop, Reason, State}
%% @end
%%--------------------------------------------------------------------
handle_cast(_Msg, State) ->
    {noreply, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Handling all non call/cast messages
%%
%% @spec handle_info(Info, State) -> {noreply, State} |
%%                                   {noreply, State, Timeout} |
%%                                   {stop, Reason, State}
%% @end
%%--------------------------------------------------------------------
handle_info({Port,{data,Data}}, 
	     #state{port = Port}=State) ->
    process_frame(Data, State),
    {noreply, State};
handle_info({Port,{exit_status,0}},
	    #state{port = Port} = State) ->
%    ?dbg([]),
    {stop, normal, State};
handle_info({Port,{exit_status,Status}},
	    #state{port = Port, db = Device}=State) ->
    ?dbg([Device,Status]),
    {stop, Status, State};
handle_info({Port, eof}, 
	    #state{port = Port, db = Device}=State) ->
    ?dbg([Device]),
    Port ! {self(), close},
    {noreply, State};
handle_info({Port, closed},    
	    #state{port = Port, db = Device}=State) ->
    ?dbg([Device]),
    {stop,<<"Port Closed">>,State};

handle_info({'EXIT', Port, PosixCode},    
	    #state{port = Port, db = Device}=State) ->
    ?dbg([Device,PosixCode]),
    {stop,PosixCode,State};
handle_info({'EXIT', From, Reason},
	    #state{port = Port, db = Db}=State) ->
    ?dbg([Db,From,Reason, Port]),
%    1 = ets:select_delete(Db, 
%			  ets:fun2ms( fun({_,Pid}) 
%			    when Pid == From -> true end)),
    {noreply, State};
handle_info(Info, State) ->
    ?dbg([Info, State]),
    {noreply, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% This function is called by a gen_server when it is about to
%% terminate. It should be the opposite of Module:init/1 and do any
%% necessary cleaning up. When it returns, the gen_server terminates
%% with Reason. The return value is ignored.
%%
%% @spec terminate(Reason, State) -> void()
%% @end
%%--------------------------------------------------------------------
terminate(Reason, #state{port = Port, db = Db} = State) ->
    terminate1(Reason,State),
    erlang:port_close(Port),
    ets:delete(Db),
    ok.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Convert process state when code is changed
%%
%% @spec code_change(OldVsn, State, Extra) -> {ok, NewState}
%% @end
%%--------------------------------------------------------------------
code_change(_OldVsn, State, _Extra) ->
    {ok, State}.

%%%===================================================================
%%% Internal functions
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc process_frame
%% @spec process_frame(Data) -> ok
%% processes ethernet frame received from device
%% @end
%%--------------------------------------------------------------------

-spec process_frame(binary(), #state{}) ->
    ok.
process_frame(<<PcapRecHdr:24/binary, MACFrame/binary>>, 
	      State) ->
    process_frame(PcapRecHdr, MACFrame, State);
process_frame(PcapRec, _State) ->
    ?dbg(PcapRec).

process_frame( <<Seconds:32/native,
		 0:32,
		 Micro:32/native,
		 0:32,
		 CapLen:32/native,
		 Len:32/native>>,

	       <<_DA:6/binary,
		 _SA:6/binary,
		 8,0, % IP
		 4:4, % IPv4
		 HdrLen:4,
		 _TOS,
		 _TotalLen:16,
		 _Id:16,
		 _FlagsOffset:16,
		 _TTL,
		 6, % TCP
		 _HdrChkSum:16,
		 SIP:4/binary,
		 DIP:4/binary,
		 RestFrame/binary>> = Frame, 
	       #state{db = Db, filters = Filters}) 
  when HdrLen >= 5,
       4*HdrLen + ?TCP_MIN_HDR_LEN =< size(Frame) ->
    OptsLen = 4 * (HdrLen - ?IP_MIN_HDR_LEN),
    << _Opts:OptsLen/binary, SP:16, DP:16, RestPDU/binary >> 
	= RestFrame,
    FiveTuple =#five_tuple{ sip = SIP, 
		  dip = DIP, 
		  proto = 6, 
		  sp = SP, 
		  dp = DP },
    Key = list_to_tuple(lists:sort([SIP,DIP,SP,DP])),
    PcapRec = <<Seconds:32, Micro:32, CapLen:32, Len:32, 
		Frame/binary>>,
 	    Msg = #msg{sender = self(),
		       session_key = Key,
		       ts = {Seconds, 
			     Micro},
		       len = Len,
		       five_tuple = FiveTuple,
		       pdu = RestPDU,
		       pcap_record = PcapRec},
   process_session(Msg,Db,Key,ets:lookup(Db,Key), Filters);
process_frame(_Hdr_, _Frame, _Db) ->
%    io:format("~p~n", [Frame]).
 ok.

process_session(#msg{sender = S,
		    session_key = K,
		     ts = T,
		     five_tuple = FT,
		     pdu = <<Seq:32, 
			     _Ack:32,
			     HdrLen:4,
			     _Flags:7,
			     0:1, % NOT ACK
			     _PUSH:1,
			     0:1, % NOT RST
			     1:1, % SYN
			     0:1, % NOT FIN
			     _Rest/binary>>,
		    pcap_record = PcapRec},
		Db,Key,[], Filters) when HdrLen * 4 >= ?TCP_MIN_HDR_LEN ->
    {ok, Session} = session:start_link(#syn_msg{sender = S,
						session_key = K,
						ts = T,
						five_tuple = FT,
						seq = Seq,
						pcap_record = PcapRec,
						filters = Filters}),
    true = ets:insert_new(Db, {Key,Session});

process_session(Msg,_Db,Key,[{Key,Pid}], _Filters) ->
    session:send(Pid, Msg).


% terminate1(normal,_State) -> ok;
terminate1(Reason, State) -> ?dbg([Reason,State]).

