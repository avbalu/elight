%%%-------------------------------------------------------------------
%%% @author adoor balasubramanian <balu@localhost.localdomain>
%%% @copyright (C) 2014, adoor balasubramanian
%%% @doc
%%% The end_cause in #state{} represents the reason for session termination
%%  When the session ends in established state with atleast one completed transaction, then the end_cause is considered normal, irrespective of who close the connection and how.
%%% When the session ends in aw_response state, the end_cause is not normal even if soem transactions ahve been completed succussfully in the session.

%%% when timeout occurs before any transaction has completed or while in aw_response state, end_cause will be set to timeout

%%% in case of timeout, t_last_msg + timeout is used to calculate session duration
%%% Todo: retransmission, pipelining
%%% @end
%%% Created : 30 Dec 2014 by adoor balasubramanian <balu@localhost.localdomain>
%%%-------------------------------------------------------------------
-module(session).

-behaviour(gen_fsm).

-include("../../common/common.hrl").
-include("../../filer/include/filer.hrl").
-include("../../api/include/event_mgr.hrl").

%% API
-export([start_link/1, send/2]).
-compile(export_all).

%% gen_fsm callbacks
-export([init/1, state_name/2, state_name/3, handle_event/3,
	 handle_sync_event/4, handle_info/3, terminate/3, code_change/4]).

%% state functions
-export([aw_syn_ack/2, aw_ack_syn_ack/2, established/2,
	aw_response/2]).

-type state() :: idle |
		 aw_syn | 
		 aw_syn_ack | 
		 aw_ack_syn_ack | 
		 first_req |
		 established |
		 aw_response.

%% @doc sequence numbers
%% used to indetify retransmissions
%% seq and ack numbers are used to match response to request
%% cseq - client sequence number 
%% sseq_expected_by_c - sequence number expected by client from server
%% these two are copied from seq and acknum fields, respectively, from
%% each client packet.

%% sseq - server sequence number
%% cseq_exp_by_s - sequence number expected by server from client
%% these two are copied from each server packet

%% @TODO In case of pipelined HTTP/1.1 requests, the above alogorithm 
%% addresses request/response matching of only first pair.
%% match all request/response pairs in case of pipleling is TBD.
%% current state = hd(states)

-record(state, { session_key :: tuple(),
		 sniffer :: pid(),
		 session :: #session{},
		 t_start :: time(),
		 latency = 0 :: latency(),
		 end_cause :: end_cause(),
		 retrans = 0 :: non_neg_integer(),
		 transactions = [] :: [#transaction{}],

		 cseq0 :: non_neg_integer(),
		 cseq :: pos_integer(),
		 cseq_next :: pos_integer(),
		 sseq_exp_by_c :: pos_integer(),

		 sseq0 :: non_neg_integer(),
		 sseq :: pos_integer(),
		 sseq_next :: pos_integer(),
		 cseq_exp_by_s :: pos_integer(),

		 states = [] :: [state()], % in reverse order

		 t_last_msg :: time(),
		 pcap_records :: [binary()],
		 filters :: [#filter{}]
	       }).
%%%===================================================================
%%% API
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% Creates a gen_fsm process which calls Module:init/1 to
%% initialize. To ensure a synchronized start-up procedure, this
%% function does not return until Module:init/1 has returned.
%%
%% @spec start_link() -> {ok, Pid} | ignore | {error, Error}
%% @end
%%--------------------------------------------------------------------
start_link(Args) ->
    gen_fsm:start_link(?MODULE, Args, [{debug,[{log_to_file,"/home/balu/elight/lib/monitor/log/session.log"}]}]).

send(FsmRef, Event) when is_pid(FsmRef)->
    gen_fsm:send_event(FsmRef, Event).

%%%===================================================================
%%% gen_fsm callbacks
%%%===================================================================

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Whenever a gen_fsm is started using gen_fsm:start/[3,4] or
%% gen_fsm:start_link/[3,4], this function is called by the new
%% process to initialize.
%%
%% @spec init(Args) -> {ok, StateName, State} |
%%                     {ok, StateName, State, Timeout} |
%%                     ignore |
%%                     {stop, StopReason}
%% @end
%%--------------------------------------------------------------------
init(#msg{sender = Name,
		       session_key = Key,
		       ts = #timeStamp{seconds = Seconds, 
			     micro = Micro},
		       len = Len,
		       five_tuple = FiveTuple,
		       tcp_hdr = #tcp_hdr{seq = Seq}
		       data_len = DataLen,
		       pcap_record = PcapRec},
     Filters) ->
    {ok, aw_syn_ack, 
     #state{session_key = K, 
	    sniffer = Name,
	    session = #session{client = SIP, 
			       server = DIP, 
			       port = DP},
	    t_start = T,
	    cseq0 = Seq,
	    cseq_next = 1 + DataLen,
	    states = [aw_syn_ack]
	    t_last_msg = T,
	    pcap_records = [PcapRec],
	    filters = Filters
	   }, 
     ?MSG_TIMEOUT}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% There should be one instance of this function for each possible
%% state name. Whenever a gen_fsm receives an event sent using
%% gen_fsm:send_event/2, the instance of this function with the same
%% name as the current state name StateName is called to handle
%% the event. It is also called if a timeout occurs.
%%
%% In all States we need to take care of 
%% timeout
%% session end (FIN/RST)
%% retransmission,
%% just ACK without Data  
%% TCP fragments/ message from unexpected direction
%% normal case
%% unexpected message
%% All packets except the initial SYN packet from the client should have the ACK bit set
%% @spec state_name(Event, State) ->
%%                   {next_state, NextStateName, NextState} |
%%                   {next_state, NextStateName, NextState, Timeout} |
%%                   {stop, Reason, NewState}
%% @end
%%--------------------------------------------------------------------


%% SYN comes in as part of session init.

%% @doc aw_syn_ack

%% timeout
aw_syn_ack(timeout, State) ->
    timeout(State, no_syn_ack);

%% session end (FIN/RST)
aw_syn_ack(#msg{tcp_hdr{f=Fin, r=Rst}}, State) when Fin;Rst ->
      end_session(Rst, Msg, update(idle,Msg, State), no_syn_ack);

%% SYN retransmission
aw_syn_ack(#msg{
	      five_tuple = #five_tuple{sip = SIP, dip = DIP, dp = DP}, 
	      tcp_hdr = #tcp_hdr{seq = Seq,
				 s = true,
				 r = false,
				 f = false,
				 a = false} = Msg},
	   #state{cseq0 = Seq,
		  session = #session{client = SIP, 
				     server = DIP, 
				     port = DP},
		  retrans = SR} = State) ->
    NewState = update(aw_syn_ack, Msg, State#state{
					  retrans = SR + 1}),
    {next_state, aw_syn_ack, NewState, ?MSG_TIMEOUT};
		  
%% just ACK without Data  
%% normal case
aw_syn_ack(#msg{ % SYN_ACK
	      ts=T,
	      five_tuple = #five_tuple{sip = SIP, dip = DIP, sp = SP},
	      tcp_hdr = #tcp_hdr{seq = Seq,
				 ack = Ack,
				 a = true,
				 r = false,
				 s = true,
				 f = false},
	     data_len = DataLen} = Msg,
	   #state{cseq0 = CSeq0,
		  cseq_next = CSeqN,
		  t_start = T0,
		  session = #session{client = DIP,
				     server = SIP,
				     port = SP}
		 } = State) 
when CSeqN = Ack - CSeq0 ->
     NewState = 
	update(aw_ack_syn_ack,Msg, State#state{ latency = latency(T0,T),
				    sseq0 = Seq,
				    sseq = 0,
				    sseq_next = 1 + DataLen}),
    {next_state, aw_ack_syn_ack, NewState, ?MSG_TIMEOUT};
	      
%% unexpected message
aw_syn_ack(Msg,State) ->
    {next_state, aw_syn_ack, unexpected(aw_syn_ack, Msg, State), 
     ?MSG_TIMEOUT}.
%%----------
%% @doc aw_ack_syn_ack
%%----------------
%% timeout
aw_ack_syn_ack(timeout, State) ->
    timeout(State, no_ack_syn_ack);

%% session end (FIN/RST)
aw_ack_syn_ack(#msg{tcp_hdr = #tcp_hdr{r=Rst,
				       f=Fin}				
		   } = Msg, 
	       State) when Fin; Rst ->
    end_session(Rst,Msg,update(idle,Msg, State), 
		no_client_request);

%% retransmission,
aw_ack_syn_ack(#msg{ % SYN Retransmission
		  five_tuple = #five_tuple{sip = SIP, dip = DIP, dp = DP}, 
		  tcp_hdr = #tcp_hdr{seq = Seq,
				     s = true,
				     r = false,
				     f = false,
				     a = false} = Msg},
	       #state{cseq0 = Seq,
		      session = #session{client = SIP, 
					 server = DIP, 
					 port = DP},
		      retrans = SR} = State) ->
    NewState = update(aw_ack_syn_ack, Msg, State#state{
					  retrans = SR + 1}),
   {next_state, aw_ack_syn_ack, NewState, ?MSG_TIMEOUT};

aw_ack_syn_ack(#msg{ % SYN_ACK retransmission
	      ts=T,
	      five_tuple = #five_tuple{sip = SIP, dip = DIP, sp = SP},
	      tcp_hdr = #tcp_hdr{seq = Seq,
				 ack = Ack,
				 a = true,
				 r = false,
				 s = true,
				 f = false},
	     data_len = DataLen} = Msg,
	   #state{cseq0 = CSeq0,
		  cseq_next = CSeqN,
		  t_start = T0,
		  session = #session{client = DIP,
				     server = SIP,
				     port = SP}
		 } = State) 
when CSeqN = Ack - CSeq0 ->
     NewState = 
	update(aw_ack_syn_ack, Msg, State#state{ latency = latency(T0,T)}),
   {next_state, aw_ack_syn_ack, NewState, ?MSG_TIMEOUT};


%% just ACK without Data  
%% normal case
aw_ack_syn_ack(#msg{ % ackSynAck
		  five_tuple = #five_tuple{sip = SIP, dip = DIP, dp = DP}, 
		  tcp_hdr = #tcp_hdr{seq = Seq,
				     ack = Ack,
				     a = true},
		  data_len = DataLen}= Msg},
	       #state{sseq0 = SSeq0,
		      sseq_next = SSeqN,
		      session = #session{client = SIP, 
					 server = DIP, 
					 port = DP
					}
		     } = State) 
when Ack - SSeq0 =:= sseq_next ->
    CSeq = Seq - CSeq0,
    NewState = State#state{cseq = CSeq,
			   cseq_next = CSeq + DataLen},
    {next_state, first_req_response, update(first_req_response,
					    Msg, NewState), ?MSG_TIMEOUT};

%% unexpected message
aw_ack_syn_ack(Msg, State) ->    
    {next_state, aw_ack_syn_ack, 
     unexpected(aw_ack_syn_ack, Msg, State), ?MSG_TIMEOUT}.

%---------------------------
established(timeout, #state{transactions = []} = State) ->
    timeout(State, no_client_request);
first_req_response(timeout,State) ->
    timeout(State,normal);
first_req_response(#msg{ %  session end
	  pdu = <<_Seq:32, 
		  _Ack:32,
		  HdrLen:4,
		  _Flags:7,
		  _A:1, % ACK
		  _Push:1,
		  R:1, % RST
		  _S:1, % SYN
		  F:1, % FIN
		  _Rest/binary
		>> } = Msg, 
	    #state{  transactions = []
	      } = State) 
  when HdrLen * 4 >= ?TCP_MIN_HDR_LEN, F + R > 0 ->
	
     end_session(R,Msg,update(Msg, State), no_client_request);
first_req_response(#msg{ %  session end
	  pdu = <<_Seq:32, 
		  _Ack:32,
		  HdrLen:4,
		  _Flags:7,
		  _A:1, % ACK
		  _Push:1,
		  R:1, % RST
		  _S:1, % SYN
		  F:1, % FIN
		  _Rest/binary
		>> } = Msg, 
	     State) 
  when HdrLen * 4 >= ?TCP_MIN_HDR_LEN, F + R > 0 ->
     end_session(R,Msg,update(Msg, State), normal);
first_req_response(#msg{ % SYN Retransmission
	  five_tuple = #five_tuple{sip = SIP, dip = DIP, dp = DP}, 
	  pdu = <<_Seq:32, 
		  _Ack:32,
		  HdrLen:4,
		  _Flags:7,
		  0:1, % NOT ACK
		  _PUSH:1,
		  0:1, % NOT RST
		  1:1, % SYN
		  0:1, % NOT FIN
		  _Rest/binary
		>> } = Msg, 
       #state{ 
	       session = #session{client = SIP, 
				  server = DIP, 
				  port = DP},
	       retrans = SR} = State)
  when HdrLen * 4 >= ?TCP_MIN_HDR_LEN  ->
    NewState = (update(Msg, State))#state{retrans = SR + 1},
    {next_state, first_req_response, NewState, ?MSG_TIMEOUT};
first_req_response(#msg{ % SYN_ACK retransmission
	  five_tuple = #five_tuple{sip = SIP, dip = DIP, sp = SP}, 
	  pdu = <<SSeq:32, 
		  Ack:32,
		  HdrLen:4,
		  _Flags:7,
		  1:1, % ACK
		  _PUSH:1,
		  0:1, % NOT RST
		  1:1, % SYN
		  0:1, % NOT FIN
		  _Rest/binary
		>>} = Msg, 
	       #state{
		  cseq = Ack, % Seq(ACK_SYN_ACK)
		  sseq = SSeq,
		  session = #session{client = DIP,
				     server = SIP,
				     port = SP},
		  retrans = SR
		 } = State) 
when HdrLen * 4 >= ?TCP_MIN_HDR_LEN
 ->
    NewState = (update(Msg, State))#state{retrans = SR + 1},
    {next_state, first_req_response, NewState, ?MSG_TIMEOUT};
first_req_response(#msg{five_tuple = #five_tuple{sip = SIP, dip = DIP, sp = SP}, 
		 pdu = PDU} = Msg,
	    #state{
	       session = #session{client = SIP, 
				  server = DIP, 
				  port = DP}} = State) ->
    establihsed_c_pkt(Msg, State, Data);
first_req_response_c_pkt(#msg{
	  pdu = <<SSeq:32, 
		  Ack:32,
		  HdrLen:4,
		  _Flags:7,
		  _A:1, % ACK
		  _PUSH:1,
		  0:1, % NOT RST
		  0:1, % SYN
		  0:1, % NOT FIN,
		  _WindowSize:16,
		  _ChkSum:16,
		  _UrgentPointer:16,
		  _Rest/binary
		>> } = Msg, 
		  #state{
		     cseq = SSeqsseq_exp_by_c = SSeq,
		   cseq_exp_by_s = Ack} = State,
		  
first_req_response(#msg{ % unsolicited  server response 
	  five_tuple = #five_tuple{sip = SIP, dip = DIP, sp = SP}, 
	  pdu = <<SSeq:32, 
		  Ack:32,
		  HdrLen:4,
		  _Flags:7,
		  _A:1, % ACK
		  _PUSH:1,
		  0:1, % NOT RST
		  0:1, % SYN
		  0:1, % NOT FIN,
		  _WindowSize:16,
		  _ChkSum:16,
		  _UrgentPointer:16,
		  _Rest/binary
		>> } = Msg, 
	    #state{sseq_exp_by_c = SSeq,
		   cseq_exp_by_s = Ack,
		   session = #session{client = DIP,
				     server = SIP,
				     port = SP}
	      } = State) 
when HdrLen * 4  >= ?TCP_MIN_HDR_LEN ->
    {next_state, first_req_response, update(Msg, State), ?MSG_TIMEOUT};
first_req_response(#msg{ % server message
	  five_tuple = #five_tuple{sip = SIP, dip = DIP, sp = SP}, 
	  pdu = <<Seq:32, 
		  Ack:32,
		  HdrLen:4,
		  _Flags:7,
		  _A:1, % ACK
		  _PUSH:1,
		  0:1, % NOT RST
		  0:1, % SYN
		  0:1, % NOT FIN,
		  _WindowSize:16,
		  _ChkSum:16,
		  _UrgentPointer:16,
		  _Rest/binary
		>> } = Msg, 
	    #state{sseq_exp_by_c = SSeq,
		   cseq_exp_by_s = Ack,
		   session = #session{client = DIP,
				     server = SIP,
				     port = SP}
	      } = State) 
when HdrLen * 4  >= ?TCP_MIN_HDR_LEN, Seq > SSeq ->
    NewState = State#state{sseq = Seq},
    {next_state, first_req_response, update(Msg, NewState), ?MSG_TIMEOUT};
first_req_response(#msg{ % server response retransmission or just Ack retrans
	  five_tuple = #five_tuple{sip = SIP, dip = DIP, sp = SP}, 
	  pdu = <<SSeq:32, 
		  Ack:32,
		  HdrLen:4,
		  _Flags:7,
		  _A:1, % ACK
		  _PUSH:1,
		  0:1, % NOT RST
		  0:1, % SYN
		  0:1, % NOT FIN,
		  _WindowSize:16,
		  _ChkSum:16,
		  _UrgentPointer:16,
		  Rest/binary
		>> } = Msg, 
	    #state{sseq = SSeq,
		   session = #session{client = DIP,
				     server = SIP,
				     port = SP}
	      } = State) 
when HdrLen * 4  >= ?TCP_MIN_HDR_LEN ->
    OptionsLength = HdrLen * 4 - ?TCP_MIN_HDR_LEN,
    <<_Options:OptionsLength/binary, Data/binary>> = Rest,
    NewState = State#state{
			    cseq_exp_by_s = Ack},
    NewState1 = response_retrans(Msg,	update(Msg, NewState) , Data),
    {next_state, first_req_response, NewState1, ?MSG_TIMEOUT};

first_req_response(#msg{ % acksynack retrans
	  five_tuple = #five_tuple{sip = SIP, dip = DIP, dp = DP}, 
	  pdu = <<CSeq:32, 
		  Ack:32,
		  HdrLen:4,
		  _Flags:7,
		  1:1, % ACK
		  _PUSH:1,
		  0:1, % NOT RST
		  0:1, % NOT SYN
		  0:1, % NOT FIN
		  _WindowSize:16,
		  _ChkSum:16,
		  _UrgentPointer:16,
		  Rest/binary
		>> } = Msg, 
	    #state{ cseq = CSeq,
		      session = #session{client = SIP, 
					 server = DIP, 
					 port = DP
					}
		  } = State) 
  when HdrLen * 4 >= ?TCP_MIN_HDR_LEN ->
    OptionsLength = HdrLen * 4 - ?TCP_MIN_HDR_LEN,
    <<_Options:OptionsLength/binary, Data/binary>> = Rest,
    NewState = State#state{
			   },
    first_req_response(Msg,update(Msg, NewState), Data);
first_req_response(Msg, State) ->
    {next_state, first_req_response, unexpected(Msg, State), ?MSG_TIMEOUT}.

aw_response(timeout, State) ->
    timeout(State, no_server_response);
aw_response(#msg{ % SYN_ACK retransmission
	  five_tuple = #five_tuple{sip = SIP, dip = DIP, sp = SP}, 
	  pdu = <<SSeq:32, 
		  _Ack:32,
		  HdrLen:4,
		  _Flags:7,
		  1:1, % ACK
		  _PUSH:1,
		  0:1, % NOT RST
		  1:1, % SYN
		  0:1, % NOT FIN
		  _Rest/binary
		>>} = Msg, 
	       #state{
		  sseq = SSeq,
		  session = #session{client = DIP,
				     server = SIP,
				     port = SP},
		  retrans = SR
		 } = State) 
when HdrLen * 4 >= ?TCP_MIN_HDR_LEN ->
    NewState = (update(Msg, State))#state{retrans = SR + 1},
    {next_state, aw_response, NewState, ?MSG_TIMEOUT};
aw_response(#msg{ % Client Request retransmission
	  five_tuple = #five_tuple{sip = SIP, dip = DIP, dp = DP}, 
	  pdu = <<CSeq:32, 
		  Ack:32,
		  HdrLen:4,
		  _Flags:7,
		  1:1, % ACK
		  _PUSH:1,
		  0:1, % NOT RST
		  0:1, % NOT SYN
		  0:1, % NOT FIN
		  _WindowSize:16,
		  _ChkSum:16,
		  _UrgentPointer:16,
		  Rest/binary
		>> } = Msg, 
	    #state{cseq = CSeq,
		   session = #session{client = SIP, 
				      server = DIP, 
				      port = DP
				     },
		   transactions = [#transaction{retrans =R}=Tr|RT]
		  } = State) 
  when HdrLen * 4 >= ?TCP_MIN_HDR_LEN ->
    OptionsLength = HdrLen * 4 - ?TCP_MIN_HDR_LEN,
    <<_Options:OptionsLength/binary, _Data/binary>> = Rest,
    NewState = State#state{
		 sseq_exp_by_c = Ack,
		 transactions = [Tr#transaction{retrans = R+1} | RT]},
    {next_state, aw_response, update(Msg, NewState), ?MSG_TIMEOUT};
aw_response(#msg{ %  session end
	  pdu = <<_Seq:32, 
		  _Ack:32,
		  HdrLen:4,
		  _Flags:7,
		  _A:1, % ACK
		  _Push:1,
		  R:1, % RST
		  _S:1, %  SYN
		  F:1, % FIN
		  _Rest/binary
		>> } = Msg, 
	     State) 
  when HdrLen * 4 >= ?TCP_MIN_HDR_LEN, F + R > 0 -> 	
    end_session(R,Msg,update(Msg, State),no_server_response);
aw_response(#msg{ % server response or just Ack
	  five_tuple = #five_tuple{sip = SIP, dip = DIP, sp = SP}, 
	  pdu = <<SSeq:32, 
		  Ack:32,
		  HdrLen:4,
		  _Flags:7,
		  _A:1, % ACK
		  _PUSH:1,
		  0:1, % NOT RST
		  0:1, % SYN
		  0:1, % NOT FIN,
		  _WindowSize:16,
		  _ChkSum:16,
		  _UrgentPointer:16,
		  Rest/binary
		>> } = Msg, 
	    #state{
		  session = #session{client = DIP,
				     server = SIP,
				     port = SP},
	       sseq_exp_by_c = SSeq
	      } = State) 
when HdrLen * 4  >= ?TCP_MIN_HDR_LEN ->
    OptionsLength = HdrLen * 4 - ?TCP_MIN_HDR_LEN,
    <<_Options:OptionsLength/binary, Data/binary>> = Rest,
    NewState = State#state{ sseq = SSeq,
			    cseq_exp_by_s = Ack},
    aw_response(Msg,	update(Msg, NewState) , Data);
aw_response(Msg,State) ->
    {next_state, aw_response,unexpected (Msg,State), ?MSG_TIMEOUT}.

state_name(_Event, State) ->
    {next_state, state_name, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% There should be one instance of this function for each possible
%% state name. Whenever a gen_fsm receives an event sent using
%% gen_fsm:sync_send_event/[2,3], the instance of this function with
%% the same name as the current state name StateName is called to
%% handle the event.
%%
%% @spec state_name(Event, From, State) ->
%%                   {next_state, NextStateName, NextState} |
%%                   {next_state, NextStateName, NextState, Timeout} |
%%                   {reply, Reply, NextStateName, NextState} |
%%                   {reply, Reply, NextStateName, NextState, Timeout} |
%%                   {stop, Reason, NewState} |
%%                   {stop, Reason, Reply, NewState}
%% @end
%%--------------------------------------------------------------------
state_name(_Event, _From, State) ->
    Reply = ok,
    {reply, Reply, state_name, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Whenever a gen_fsm receives an event sent using
%% gen_fsm:send_all_state_event/2, this function is called to handle
%% the event.
%%
%% @spec handle_event(Event, StateName, State) ->
%%                   {next_state, NextStateName, NextState} |
%%                   {next_state, NextStateName, NextState, Timeout} |
%%                   {stop, Reason, NewState}
%% @end
%%--------------------------------------------------------------------
handle_event(_Event, StateName, State) ->
    {next_state, StateName, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Whenever a gen_fsm receives an event sent using
%% gen_fsm:sync_send_all_state_event/[2,3], this function is called
%% to handle the event.
%%
%% @spec handle_sync_event(Event, From, StateName, State) ->
%%                   {next_state, NextStateName, NextState} |
%%                   {next_state, NextStateName, NextState, Timeout} |
%%                   {reply, Reply, NextStateName, NextState} |
%%                   {reply, Reply, NextStateName, NextState, Timeout} |
%%                   {stop, Reason, NewState} |
%%                   {stop, Reason, Reply, NewState}
%% @end
%%--------------------------------------------------------------------
handle_sync_event(_Event, _From, StateName, State) ->
    Reply = ok,
    {reply, Reply, StateName, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% This function is called by a gen_fsm when it receives any
%% message other than a synchronous or asynchronous event
%% (or a system message).
%%
%% @spec handle_info(Info,StateName,State)->
%%                   {next_state, NextStateName, NextState} |
%%                   {next_state, NextStateName, NextState, Timeout} |
%%                   {stop, Reason, NewState}
%% @end
%%--------------------------------------------------------------------
handle_info(_Info, StateName, State) ->
    {next_state, StateName, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% This function is called by a gen_fsm when it is about to
%% terminate. It should be the opposite of Module:init/1 and do any
%% necessary cleaning up. When it returns, the gen_fsm terminates with
%% Reason. The return value is ignored.
%%
%% @spec terminate(Reason, StateName, State) -> void()
%% @end
%%--------------------------------------------------------------------
terminate(normal, _StateName, _State) ->
    ok;
terminate(Reason, StateName, State) ->
     ?dbg([Reason, StateName, State]),
    ok.
%%--------------------------------------------------------------------
%% @private
%% @doc
%% Convert process state when code is changed
%%
%% @spec code_change(OldVsn, StateName, State, Extra) ->
%%                   {ok, StateName, NewState}
%% @end
%%--------------------------------------------------------------------
code_change(_OldVsn, StateName, State, _Extra) ->
    {ok, StateName, State}.

%%%===================================================================
%%% Internal functions
%%%===================================================================
end_session(#state{session_key = Key,
		   sniffer = Sniffer,
		   t_last_msg = Tl,
		   session = Session,
		   t_start = Ts,
		   latency = L,
		   end_cause = Cause,
		   retrans = SR,
		   transactions = Tr,
		   pcap_records = Rs,
		   filters = Filters
		  } = State, Error) ->
    SU = #session_update{
	    session = Session,
	    t_start = Ts,
	    latency = L,
	    t_end = Tl, 
	    end_cause = Cause,
	    error_code = Error,
	    syn_retrans = SR,
	    transactions = Tr},
    act(Session, Rs, match:match(SU, Filters)),
    admin:session_update(SU),
    sniffer:end_session(Sniffer,Key),
    {stop, normal, State}. 

act(_Session, _PcapRecords, none) ->
    ok;
act(Session, PcapRecords, Filter) ->
    action:act(Session, PcapRecords, Filter).

%% @doc
-spec latency(T1 :: time(), T2 :: time()) ->
			   T :: latency().
latency(#timeStamp{seconds = S1, micro = U1} = T1,
	 #timeStamp{seconds = S2, micro = U2}      = T2) when T1 < T2 ->
    (S2-S1)*1000000 + (U2-U1).

    
update(#msg{sender = Sniffer, session_key = Key, 
	      ts = T, pcap_record = R},
	 #state{sniffer = Sniffer, session_key = Key, 
		pcap_records = Rs} = State) -> 
    State#state{t_last_msg = T, pcap_records = [R|Rs]}.
    

-spec xx_update(Msg :: #msg{}, State :: #state{} ) -> NewState :: #state{}.
xx_update(#msg{five_tuple = #five_tuple{sip = SIP, dip = DIP, dp = DP}
	   } = Msg, 
       #state{
	       session = #session{client = SIP, 
				  server = DIP, 
				  port = DP}
	     } = State) ->    
    rx_update(Msg,State);
xx_update(Msg,State) -> 
    tx_update(Msg,State).

rx_update(#msg{len=L},
	  #state{transactions = [#transaction{rx_bytes = B, rx_frames = F} = Tr | Rest]} = State) ->
     State#state{transactions = [Tr#transaction{rx_bytes = B+L, rx_frames = F+1} | Rest]}.


tx_update(#msg{len=L},
	  #state{transactions = [#transaction{tx_bytes = B, tx_frames = F} = Tr | Rest]} = State) ->
    State#state{transactions = [Tr#transaction{tx_bytes = B+L, tx_frames = F+1} | Rest]}.

-spec unexpected(Msg :: #msg{}, State :: #state{}) -> NewState :: #state{}.
unexpected(Msg,State) ->
    NewState = update(Msg, State),
    ?dbg([Msg,NewState]),
    store_unexpected(Msg, NewState),
    NewState.



client_close(1) ->
    c_rst;
client_close(_R) ->
    c_fin.

server_close(1) ->
    s_rst;
server_close(_R) ->
    s_fin.

end_cause(#five_tuple{sip = SIP, dip = DIP, dp = DP},
	  #session{client = SIP, 
		   server = DIP, 
		   port = DP
		  },
	  R) ->
    client_close(R);
end_cause(_FT, _Session, R) ->
    server_close(R).

-spec timeout( State :: #state{} , Error :: error_code()) ->
	 {stop, normal, NewState :: #state{}}. 
timeout(State, Error) ->
    end_session(State#state{
			   end_cause = timeout}, Error).
	

end_session(R, #msg{five_tuple = FT},
	     #state{session = Session} = State, Error) -> 
    end_session(State#state{end_cause = end_cause(FT,Session,R)}, Error).



-spec response_retrans(Msg :: #msg{}, 
		  State :: #state{}, 
		  Data :: binary()) ->
			      NewState :: #state{}.
response_retrans(_Msg, State, <<>>) -> % just Ack
    State;
response_retrans(#msg{ts =T },
 	    #state{
	       transactions =  [#transaction{t_start = T0,
					    retrans = R} = Perf|RT]
	      } = State,
	   _Data) ->
    Perf1 = Perf#transaction{
	      retrans = R + 1,
	      latency = latency(T0 , T)
	     }, 
State#state{ 
		 transactions = [Perf1 |RT]
		}.

%% @doc State Helper Functions
-spec aw_response(Msg :: #msg{}, 
		  State :: #state{}, 
		  Data :: binary()) ->
			 {NS :: next_state,
			  NS1 :: state(),
			  NewState:: #state{},
			  T :: ?MSG_TIMEOUT}.
aw_response(_Msg, State, <<>>) -> % just Ack
    {next_state, aw_response, State,  ?MSG_TIMEOUT};
aw_response(#msg{ts =T },
 	    #state{
	       transactions =  [#transaction{t_start = T0 } = Perf|RT]
	      } = State,
	   _Data) ->
    Perf1 = Perf#transaction{
	      latency = latency(T0 , T)
	     }, 
    NewState = State#state{ 
		 transactions = [Perf1 |RT]
		},
    {next_state, established, NewState,  ?MSG_TIMEOUT}.

-spec established(Msg :: #msg{},
		  State :: #state{}, 
		  Data :: binary()) ->
			 {NS :: next_state,
			  NS1 :: state(),
			  NewState:: #state{},
			  T :: ?MSG_TIMEOUT}.
established(_Msg, #state{retrans = SR} = State, <<>>) -> % AckSynAck retrans
    {next_state, established, State#state{retrans = SR+1}, ?MSG_TIMEOUT};
established(#msg{ % Client Request
	  ts=T,
	  pdu = <<_Seq:32, 
		  _Rest/binary>>} = Msg,
	    #state{transactions = RT} = State, 
	    _Data) ->
   NewState = State#state{ 
		 transactions = [#transaction{t_start= T}|RT]
		},
    {next_state, aw_response, rx_update(Msg, NewState), ?MSG_TIMEOUT}.
    

-spec store_terminate(Reason::any(), StateName :: state(), 
		      State :: #state{}) ->
			     ok.
store_terminate(Reason, StateName, State) ->
   Descriptor = io_lib:format(
		  "session:~p with State=~n~n~p~n~nReason=~n~n~p ", 
			       [StateName, State, Reason]),
    store(terminate, State, Descriptor).


-spec store(Type :: debug_session(), 
	    State :: #state{}, Descriptor :: iodata()) -> ok.

-spec store_unexpected(Msg :: #msg{}, State :: #state{}) -> ok.
store_unexpected(Msg, State) ->
    Descriptor = io_lib:format(
		   "unexpected msg ~n~n~w~n~n received by session with State =~n~n~w~n~n", [Msg, State]),
    store(unexpected, State, Descriptor).

store(Type, State, Descriptor) ->
    Matched = ets:update_counter(debug_session, 
				 Type, 1),
    store(Type, State, Descriptor, Matched).

-spec store(Type :: debug_session(), 
	    State :: #state{}, Descriptor :: iodata(),
	   Matched :: pos_integer()) -> ok.
store(_Type, _State, _Descriptor, Matched) when Matched > 128 -> ok;
store(Type, #state{pcap_records = Rs}, Descriptor, Matched) ->
    Name = lists:flatten(io_lib:format("debug/session/~w/~w",
				       [Type, Matched])),
    PcapFile = [?PCAP_FILE_HDR, lists:reverse(Rs)],
    action:store(Name, PcapFile, Descriptor).
