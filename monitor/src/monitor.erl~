%%%-------------------------------------------------------------------
%%% @author adoor balasubramanian <balu@localhost.localdomain>
%%% @copyright (C) 2014, adoor balasubramanian
%%% @doc
%%%
%%% @end
%%% Created : 28 Dec 2014 by adoor balasubramanian <balu@localhost.localdomain>
%%%-------------------------------------------------------------------
-module(monitor).

-behaviour(gen_server).

-include("../../common/common.hrl").

%% API
-export([start_link/2, end_session/2]).

%% gen_server callbacks
-export([init/1, handle_call/3, handle_cast/2, handle_info/2,
	 terminate/2, code_change/3]).

%%%===================================================================
%%% API
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% Starts the server
%%
%% @spec start_link(Device) -> {ok, Pid} | ignore | {error, Error}
%% @end
%%---------------------------------------------------------------------
-spec start_link(string(), string()) ->
    {ok, pid()}.

start_link(Type, Device) ->
    gen_server:start_link({local, list_to_atom(Device)}, ?MODULE, [Type, Device], []).

end_session(ServerRef, Key) ->
    gen_server:cast(ServerRef, Key).
%%%===================================================================
%%% gen_server callbacks
%%%===================================================================

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Initializes the server
%%
%% @spec init(Args) -> {ok, State} |
%%                     {ok, State, Timeout} |
%%                     ignore |
%%                     {stop, Reason}
%% @end
%%--------------------------------------------------------------------
-record(state, { port :: port(), db :: atom() }).

init([Type, Device]) ->
%    Command = filename:join(code:priv_dir(monitor) , "monitor"),
    Command = "/home/balu/elight/lib/monitor/priv/monitor",
    PortName = {spawn_executable, Command},
    PortSettings = [{packet, 2},
		    {args, [Type, Device]},
		    nouse_stdio,
		    exit_status,
		    in,
		    binary,
		    eof],
    Port = erlang:open_port(PortName, PortSettings),
    ets:new(list_to_atom(Device), [named_table]),
    erlang:process_flag(trap_exit, true),
    {ok, #state{port = Port, db = list_to_atom(Device)}}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Handling call messages
%%
%% @spec handle_call(Request, From, State) ->
%%                                   {reply, Reply, State} |
%%                                   {reply, Reply, State, Timeout} |
%%                                   {noreply, State} |
%%                                   {noreply, State, Timeout} |
%%                                   {stop, Reason, Reply, State} |
%%                                   {stop, Reason, State}
%% @end
%%--------------------------------------------------------------------
handle_call(_Request, _From, State) ->
    Reply = ok,
    {reply, Reply, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Handling cast messages
%%
%% @spec handle_cast(Msg, State) -> {noreply, State} |
%%                                  {noreply, State, Timeout} |
%%                                  {stop, Reason, State}
%% @end
%%--------------------------------------------------------------------
handle_cast(_Msg, State) ->
    {noreply, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Handling all non call/cast messages
%%
%% @spec handle_info(Info, State) -> {noreply, State} |
%%                                   {noreply, State, Timeout} |
%%                                   {stop, Reason, State}
%% @end
%%--------------------------------------------------------------------
handle_info({Port,{data,Data}}, 
	     #state{port = Port, db = Db}=State) ->
    process_frame(Data, Db),
    {noreply, State};
handle_info({Port,{exit_status,0}},
	    #state{port = Port} = State) ->
%    ?dbg([]),
    {stop, normal, State};
handle_info({Port,{exit_status,Status}},
	    #state{port = Port, db = Device}=State) ->
    ?dbg([Device,Status]),
    {stop, Status, State};
handle_info({Port, eof}, 
	    #state{port = Port, db = Device}=State) ->
    ?dbg([Device]),
    Port ! {self(), close},
    {noreply, State};
handle_info({Port, closed},    
	    #state{port = Port, db = Device}=State) ->
    ?dbg([Device]),
    {stop,<<"Port Closed">>,State};

handle_info({'EXIT', Port, PosixCode},    
	    #state{port = Port, db = Device}=State) ->
    ?dbg([Device,PosixCode]),
    {stop,PosixCode,State};
handle_info({'EXIT', From, Reason},
	    #state{port = Port, db = Db}=State) ->
    ?dbg([Db,From,Reason, Port]),
%    1 = ets:select_delete(Db, 
%			  ets:fun2ms( fun({_,Pid}) 
%			    when Pid == From -> true end)),
    {noreply, State};
handle_info(Info, State) ->
    ?dbg([Info, State]),
    {noreply, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% This function is called by a gen_server when it is about to
%% terminate. It should be the opposite of Module:init/1 and do any
%% necessary cleaning up. When it returns, the gen_server terminates
%% with Reason. The return value is ignored.
%%
%% @spec terminate(Reason, State) -> void()
%% @end
%%--------------------------------------------------------------------
terminate(Reason, #state{port = Port, db = Db} = State) ->
    ?dbg([Reason,State]),
    erlang:port_close(Port),
    ets:delete(Db),
    ok.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Convert process state when code is changed
%%
%% @spec code_change(OldVsn, State, Extra) -> {ok, NewState}
%% @end
%%--------------------------------------------------------------------
code_change(_OldVsn, State, _Extra) ->
    {ok, State}.

%%%===================================================================
%%% Internal functions
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc process_frame
%% @spec process_frame(Data) -> ok
%% processes ethernet frame received from device
%% @end
%%--------------------------------------------------------------------

-spec process_frame(binary(), atom()) ->
    ok.
process_frame(<<Seconds:64/native,
		Micro:64/native,
		_CapLen:32/native,
		Len:32/native,
		_DA:6/binary,
		_SA:6/binary,
		8,0, % IP
		4:4, % IPv4
		HdrLen:4,
		_TOS,
		_TotalLen:16,
		_Id:16,
		_FlagsOffset:16,
		_TTL,
		6, % TCP
		_HdrChkSum:16,
%		S1,S2,S3,S4, % SIP
		SIP:4/binary,
		DIP:4/binary,
%		D1,D2,D3,D4, % DIP
		RestFrame/binary>> = Frame, Db) 
  when HdrLen >= 5,
       4*HdrLen + ?TCP_MIN_HDR_LEN =< size(Frame) ->
    OptsLen = 4 * (HdrLen - ?IP_MIN_HDR_LEN),
    << _Opts:OptsLen/binary, SP:16, DP:16, RestPDU/binary >> = RestFrame,
 %   SIP = {S1,S2,S3,S4},
%  DIP = {D1,D2,D3,D4},
    FiveTuple =#five_tuple{ sip = SIP, 
		  dip = DIP, 
		  proto = 6, 
		  sp = SP, 
		  dp = DP },
    Key = list_to_tuple(lists:sort([SIP,DIP,SP,DP])),
%    io:format("~p~n", [FiveTuple]),
%    io:format("~p~n", [Frame]),
    Msg = #msg{sender = self(),
	       session_key = Key,
	       ts = {Seconds, 
			Micro},
	       len = Len,
	       five_tuple = FiveTuple,
	       pdu = RestPDU},
    process_session(Msg,Db,Key,ets:lookup(Db,Key));

process_frame(_Frame,_Db) ->
%    io:format("~p~n", [Frame]).
 ok.
   
process_session(Msg,Db,Key,[]) ->
    {ok, Session} = session:start_link({self(),Key}),
    true = ets:insert_new(Db, {Key,Session}),
    session:send(Session, Msg);
process_session(Msg,_Db,Key,[{Key,Pid}]) ->
    session:send(Pid, Msg).

